data class A(val le: Int, val ri: Int) : Comparable<A> {
    override fun compareTo(other: A) = if ((this.ri - this.le) - (other.ri - other.le) != 0)
        (other.ri - other.le) - (this.ri - this.le) else this.le - other.le
}

// Heap for min. can change to support max and no only for Int, also other class
class Heap(vararg a: A) {

    var size = 0
    var l: MutableList<A> = mutableListOf()

    init {
        for (obj in a) {
            insert(obj)
        }
    }

    fun isNotEmpty() = size != 0

    // Insert a new value.
    fun insert(obj: A): MutableList<A> {

        // Insert to last one.
        l.add(l.size, obj)
        var i = l.size - 1
        size++

        // If child smaller than parent, then bubble up
        while (l[i] < l[(i - 1) / 2]) {
            l[i] = l[(i - 1) / 2].also { l[(i - 1) / 2] = l[i] }
            i = (i - 1) / 2
        }

        // Return inserted list
        return l
    }

    // Just change the value and return, did not delete the min value
    fun popMin(): A {
        l[0] = l[l.size - 1].also { l[l.size - 1] = l[0] }
        val ans = l.removeAt(size-- - 1)
        reArrange()
        return ans
    }

    // After swap first and last, rearrange heap list.
    fun reArrange(): MutableList<A> {

        // Init loop
        var j = 0

        // Check if have left child
        while (2 * j + 1 < l.size) {
            when {

                // Check if have right child and bigger than min of child
                2 * j + 2 < l.size && l[j] > minOf(
                    l[2 * j + 1],
                    l[2 * j + 2]
                ) ->
                    when {

                        // Swap left child
                        l[2 * j + 1] < l[2 * j + 2] -> {
                            l[j] =
                                l[2 * j + 1].also {
                                    l[2 * j + 1] = l[j]
                                }
                            j = 2 * j + 1
                        }

                        // Swap right child
                        l[2 * j + 1] >= l[2 * j + 2] -> {
                            l[j] =
                                l[2 * j + 2].also {
                                    l[2 * j + 2] = l[j]
                                }
                            j = 2 * j + 2
                        }
                    }

                // Only have left child and bigger than it
                2 * j + 1 == l.size - 1 && l[j] > l[2 * j + 1] -> {

                    // Swap left child
                    l[j] =
                        l[2 * j + 1].also {
                            l[2 * j + 1] = l[j]
                        }
                    j = 2 * j + 1
                }

                // Have 2 child and {smaller than/ equal to} min of them or have left child and {smaller than/ equal to} it
                else -> return l
            }
        }
        // Do not have child and done
        return l
    }
}
